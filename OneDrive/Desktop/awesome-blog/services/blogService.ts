
import { Post } from '../types';

const posts: Post[] = [
  {
    id: '1',
    title: 'The Future of UI/UX Design with AI',
    excerpt: 'Explore how artificial intelligence is revolutionizing the way we design user interfaces and experiences, from automated design systems to personalized user journeys.',
    content: `
      <p class="mb-4">Artificial intelligence is no longer a futuristic concept; it's a present-day tool that is reshaping industries, and UI/UX design is no exception. As we venture deeper into the 21st century, AI is set to become an indispensable partner for designers, augmenting their creativity and streamlining their workflows.</p>
      <h3 class="text-2xl font-bold mt-6 mb-3">Generative Design and AI</h3>
      <p class="mb-4">One of the most exciting frontiers is generative design. AI algorithms can now generate thousands of design variations in minutes, based on a set of predefined parameters. This allows designers to explore a vast design space that would be impossible to cover manually. Tools like Adobe Sensei are already integrating these capabilities, helping create everything from logos to full website layouts.</p>
      <p class="mb-4">This doesn't mean designers will be replaced. Instead, their role will shift from pixel-pushing to curating and refining the best options generated by the AI, focusing on strategic thinking and user empathy.</p>
      <blockquote class="border-l-4 border-slate-300 pl-4 italic my-6">"AI will be the most powerful tool in a designer's toolkit. The challenge is not whether to adopt it, but how to master it."</blockquote>
      <h3 class="text-2xl font-bold mt-6 mb-3">Personalization at Scale</h3>
      <p class="mb-4">AI excels at analyzing vast amounts of user data to identify patterns and preferences. This enables hyper-personalization of user experiences. Imagine a website that dynamically adjusts its layout, content, and color scheme based on your past behavior, location, and even the time of day. Netflix and Spotify are pioneers in this area with their recommendation engines, but this is just the tip of the iceberg.</p>
      <p>The future of UI is an interface that feels uniquely tailored to each individual user, creating a more engaging and intuitive interaction.</p>
    `,
    author: 'Jane Doe',
    authorAvatar: 'https://i.pravatar.cc/150?u=jane_doe',
    date: 'October 26, 2023',
    readTime: 7,
    tags: ['AI', 'UI/UX', 'Design', 'Future'],
    imageUrl: 'https://picsum.photos/seed/ai-future/1200/800',
  },
  {
    id: '2',
    title: 'Mastering State Management in Modern React',
    excerpt: 'A deep dive into the evolution of state management in React, from prop drilling to Context API, and the rise of libraries like Redux, Zustand, and Jotai.',
    content: `
      <p class="mb-4">State management has always been a central challenge in building complex React applications. As applications grow, so does the complexity of sharing data between components. Let's trace the journey of state management and explore the modern solutions available today.</p>
      <h3 class="text-2xl font-bold mt-6 mb-3">The Old Days: Prop Drilling</h3>
      <p class="mb-4">Initially, the only way to share state was by passing props down through the component tree. This approach, known as "prop drilling," quickly becomes cumbersome and leads to tightly coupled components and maintenance nightmares.</p>
      <h3 class="text-2xl font-bold mt-6 mb-3">React's Built-in Solutions: Context API</h3>
      <p class="mb-4">The introduction of the Context API was a game-changer. It provided a native way to share state globally without prop drilling. Combined with the <code>useReducer</code> hook, it offers a powerful solution for managing complex state logic within React itself, reducing the need for external libraries for many use cases.</p>
      <blockquote class="border-l-4 border-slate-300 pl-4 italic my-6">"Context API made global state management accessible without the boilerplate of Redux."</blockquote>
      <h3 class="text-2xl font-bold mt-6 mb-3">The Rise of Modern Libraries</h3>
      <p class="mb-4">While Context is great, dedicated state management libraries still have their place. <strong>Redux</strong> remains a robust choice for large-scale applications with predictable state mutations. However, newer, more lightweight libraries like <strong>Zustand</strong> and <strong>Jotai</strong> have gained immense popularity. They offer a simpler API, less boilerplate, and a more "React-ish" feel, making them excellent choices for projects of all sizes.</p>
    `,
    author: 'John Smith',
    authorAvatar: 'https://i.pravatar.cc/150?u=john_smith',
    date: 'October 22, 2023',
    readTime: 9,
    tags: ['React', 'State Management', 'Web Development'],
    imageUrl: 'https://picsum.photos/seed/react-state/1200/800',
  },
  {
    id: '3',
    title: 'Building Accessible Web Applications: A Guide',
    excerpt: 'Accessibility (a11y) is not just a feature, it\'s a fundamental requirement. This guide covers the key principles and practical tips for building inclusive web apps.',
    content: `
      <p class="mb-4">Web accessibility (often abbreviated as a11y) is the practice of ensuring that your websites and applications are usable by everyone, regardless of their abilities or disabilities. It's not just a legal requirement in many places, but a moral and ethical one.</p>
      <h3 class="text-2xl font-bold mt-6 mb-3">The Four Principles of WCAG</h3>
      <p class="mb-4">The Web Content Accessibility Guidelines (WCAG) are built around four core principles, often remembered by the acronym POUR:</p>
      <ul class="list-disc list-inside mb-4 pl-4 space-y-2">
        <li><strong>Perceivable:</strong> Users must be able to perceive the information being presented. This means providing text alternatives for non-text content, like alt text for images.</li>
        <li><strong>Operable:</strong> Users must be able to operate the interface. This includes making all functionality available from a keyboard.</li>
        <li><strong>Understandable:</strong> Information and the operation of the user interface must be understandable. This involves using clear language and providing predictable navigation.</li>
        <li><strong>Robust:</strong> Content must be robust enough that it can be interpreted reliably by a wide variety of user agents, including assistive technologies.</li>
      </ul>
      <blockquote class="border-l-4 border-slate-300 pl-4 italic my-6">"The power of the Web is in its universality. Access by everyone regardless of disability is an essential aspect." - Tim Berners-Lee</blockquote>
      <h3 class="text-2xl font-bold mt-6 mb-3">Practical Tips for React Developers</h3>
      <p class="mb-4">As a developer, you can make a huge impact:</p>
      <ul class="list-disc list-inside mb-4 pl-4 space-y-2">
        <li><strong>Use Semantic HTML:</strong> Use <code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, <code>&lt;button&gt;</code>, etc., appropriately. They come with built-in accessibility features.</li>
        <li><strong>Manage Focus:</strong> Ensure focus is managed correctly, especially in dynamic applications and modals.</li>
        <li><strong>Use ARIA attributes wisely:</strong> Use ARIA (Accessible Rich Internet Applications) attributes to enhance accessibility where semantic HTML isn't enough.</li>
        <li><strong>Test with Screen Readers:</strong> Regularly test your app with tools like VoiceOver (macOS) or NVDA (Windows) to understand how users with visual impairments experience your site.</li>
      </ul>
    `,
    author: 'Alice Johnson',
    authorAvatar: 'https://i.pravatar.cc/150?u=alice_johnson',
    date: 'October 15, 2023',
    readTime: 6,
    tags: ['Accessibility', 'Web Development', 'a11y'],
    imageUrl: 'https://picsum.photos/seed/accessibility/1200/800',
  },
  {
    id: '4',
    title: 'The Unstoppable Rise of Tailwind CSS',
    excerpt: 'Why has Tailwind CSS, a utility-first CSS framework, taken the web development world by storm? We explore its philosophy, benefits, and why you should consider it for your next project.',
    content: `
      <p class="mb-4">In a world of component-based frameworks like React and Vue, the way we write CSS has been evolving. Tailwind CSS has emerged as a front-runner, offering a radically different, yet incredibly effective, approach to styling.</p>
      <h3 class="text-2xl font-bold mt-6 mb-3">What is Utility-First CSS?</h3>
      <p class="mb-4">Instead of writing CSS classes based on components (e.g., <code>.card</code>, <code>.button</code>), Tailwind provides low-level utility classes (e.g., <code>.bg-blue-500</code>, <code>.p-4</code>, <code>.flex</code>). You build complex components by composing these utilities directly in your HTML.</p>
      <blockquote class="border-l-4 border-slate-300 pl-4 italic my-6">"Tailwind encourages you to build custom designs without ever leaving your HTML."</blockquote>
      <h3 class="text-2xl font-bold mt-6 mb-3">Key Advantages</h3>
      <ul class="list-disc list-inside mb-4 pl-4 space-y-2">
        <li><strong>Rapid Prototyping:</strong> You can style elements incredibly fast without context-switching between your markup and stylesheets.</li>
        <li><strong>No More Naming Things:</strong> Say goodbye to agonizing over class names like <code>.user-profile-card-header-title</code>.</li>
        <li><strong>Consistency:</strong> The built-in design system (spacing, colors, etc.) ensures consistency across your entire application.</li>
        <li><strong>Performance:</strong> Tailwind automatically purges unused CSS in production, resulting in incredibly small bundle sizes.</li>
      </ul>
      <p>While the initial learning curve might involve getting used to what some call "ugly markup," the productivity gains and maintainability benefits are often a massive win for development teams.</p>
    `,
    author: 'Chris Lee',
    authorAvatar: 'https://i.pravatar.cc/150?u=chris_lee',
    date: 'September 30, 2023',
    readTime: 8,
    tags: ['CSS', 'TailwindCSS', 'Frontend'],
    imageUrl: 'https://picsum.photos/seed/tailwind-css/1200/800',
  },
];

export const getPosts = (): Promise<Post[]> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(posts);
    }, 500); // Simulate network delay
  });
};

export const getPostById = (id: string): Promise<Post | undefined> => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(posts.find((post) => post.id === id));
    }, 300); // Simulate network delay
  });
};
